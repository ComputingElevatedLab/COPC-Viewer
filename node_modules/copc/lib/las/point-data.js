"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressFile = exports.decompressChunk = exports.PointData = void 0;
const laz_perf_1 = require("laz-perf");
const header_1 = require("./header");
exports.PointData = { createLazPerf: laz_perf_1.createLazPerf, decompressChunk, decompressFile };
let ourLazPerfPromise = undefined;
async function getLazPerf(suppliedLazPerf) {
    if (suppliedLazPerf)
        return suppliedLazPerf;
    if (!ourLazPerfPromise)
        ourLazPerfPromise = (0, laz_perf_1.createLazPerf)();
    return ourLazPerfPromise;
}
async function decompressChunk(compressed, { pointCount, pointDataRecordFormat, pointDataRecordLength }, suppliedLazPerf) {
    const LazPerf = await getLazPerf(suppliedLazPerf);
    const outBuffer = new Uint8Array(pointCount * pointDataRecordLength);
    const blobPointer = LazPerf._malloc(compressed.byteLength);
    const dataPointer = LazPerf._malloc(pointDataRecordLength);
    const decoder = new LazPerf.ChunkDecoder();
    try {
        LazPerf.HEAPU8.set(new Uint8Array(compressed.buffer, compressed.byteOffset, compressed.byteLength), blobPointer);
        decoder.open(pointDataRecordFormat, pointDataRecordLength, blobPointer);
        for (let i = 0; i < pointCount; ++i) {
            decoder.getPoint(dataPointer);
            outBuffer.set(new Uint8Array(LazPerf.HEAPU8.buffer, dataPointer, pointDataRecordLength), i * pointDataRecordLength);
        }
    }
    finally {
        LazPerf._free(blobPointer);
        LazPerf._free(dataPointer);
        decoder.delete();
    }
    return outBuffer;
}
exports.decompressChunk = decompressChunk;
async function decompressFile(file, suppliedLazPerf) {
    const LazPerf = await getLazPerf(suppliedLazPerf);
    const header = header_1.Header.parse(file);
    const { pointCount, pointDataRecordLength } = header;
    const outBuffer = new Uint8Array(pointCount * pointDataRecordLength);
    const blobPointer = LazPerf._malloc(file.byteLength);
    const dataPointer = LazPerf._malloc(pointDataRecordLength);
    const reader = new LazPerf.LASZip();
    try {
        LazPerf.HEAPU8.set(new Uint8Array(file.buffer, file.byteOffset, file.byteLength), blobPointer);
        reader.open(blobPointer, file.byteLength);
        for (let i = 0; i < pointCount; ++i) {
            reader.getPoint(dataPointer);
            outBuffer.set(new Uint8Array(LazPerf.HEAPU8.buffer, dataPointer, pointDataRecordLength), i * pointDataRecordLength);
        }
    }
    finally {
        reader.delete();
    }
    return outBuffer;
}
exports.decompressFile = decompressFile;
