"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vlr = void 0;
const utils_1 = require("../utils");
const constants_1 = require("./constants");
exports.Vlr = { walk, parse, find, at, fetch };
function find(vlrs, userId, recordId) {
    return vlrs.find((v) => v.userId === userId && v.recordId === recordId);
}
function at(vlrs, userId, recordId) {
    const vlr = find(vlrs, userId, recordId);
    if (!vlr)
        throw new Error(`VLR not found: ${userId}/${recordId}`);
    return vlr;
}
function fetch(filename, { contentOffset, contentLength }) {
    const get = utils_1.Getter.create(filename);
    return get(contentOffset, contentOffset + contentLength);
}
async function walk(filename, header) {
    const get = utils_1.Getter.create(filename);
    const vlrs = await doWalk({
        get,
        startOffset: header.headerLength,
        count: header.vlrCount,
        isExtended: false,
    });
    const evlrs = await doWalk({
        get,
        startOffset: header.evlrOffset,
        count: header.evlrCount,
        isExtended: true,
    });
    return [...vlrs, ...evlrs];
}
function parse(buffer, isExtended) {
    return (isExtended ? parseExtended : parseNormal)(buffer);
}
function parseNormal(buffer) {
    const dv = utils_1.Binary.toDataView(buffer);
    if (dv.byteLength !== constants_1.vlrHeaderLength) {
        throw new Error(`Invalid VLR header length (must be ${constants_1.vlrHeaderLength}): ${dv.byteLength}`);
    }
    return {
        userId: utils_1.Binary.toCString(buffer.slice(2, 18)),
        recordId: dv.getUint16(18, true),
        contentLength: dv.getUint16(20, true),
        description: utils_1.Binary.toCString(buffer.slice(22, 54)),
        isExtended: false,
    };
}
function parseExtended(buffer) {
    const dv = utils_1.Binary.toDataView(buffer);
    if (dv.byteLength !== constants_1.evlrHeaderLength) {
        throw new Error(`Invalid EVLR header length (must be ${constants_1.evlrHeaderLength}): ${dv.byteLength}`);
    }
    return {
        userId: utils_1.Binary.toCString(buffer.slice(2, 18)),
        recordId: dv.getUint16(18, true),
        contentLength: (0, utils_1.parseBigInt)((0, utils_1.getBigUint64)(dv, 20, true)),
        description: utils_1.Binary.toCString(buffer.slice(28, 60)),
        isExtended: true,
    };
}
async function doWalk({ get, startOffset, count, isExtended }) {
    const vlrs = [];
    let pos = startOffset;
    const length = isExtended ? constants_1.evlrHeaderLength : constants_1.vlrHeaderLength;
    for (let i = 0; i < count; ++i) {
        const buffer = length ? await get(pos, pos + length) : new Uint8Array();
        const { userId, recordId, contentLength, description } = parse(buffer, isExtended);
        vlrs.push({
            userId,
            recordId,
            contentOffset: pos + length,
            contentLength,
            description,
            isExtended,
        });
        pos += length + contentLength;
    }
    return vlrs;
}
