"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Header = void 0;
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const utils_2 = require("./utils");
exports.Header = { parse };
function parse(buffer) {
    if (buffer.byteLength < constants_1.minHeaderLength) {
        throw new Error(`Invalid header: must be at least ${constants_1.minHeaderLength} bytes`);
    }
    const dv = utils_1.Binary.toDataView(buffer);
    const fileSignature = utils_1.Binary.toCString(buffer.slice(0, 4));
    console.log(fileSignature)
    if (fileSignature !== 'LASF') {
        throw new Error(`Invalid file signature: ${fileSignature}`);
    }
    const majorVersion = dv.getUint8(24);
    const minorVersion = dv.getUint8(25);
    if (majorVersion !== 1 || (minorVersion !== 2 && minorVersion !== 4)) {
        throw new Error(`Invalid version (only 1.2 and 1.4 supported): ${majorVersion}.${minorVersion}`);
    }
    const header = {
        fileSignature,
        fileSourceId: dv.getUint16(4, true),
        globalEncoding: dv.getUint16(6, true),
        projectId: (0, utils_2.formatGuid)(buffer.slice(8, 24)),
        majorVersion,
        minorVersion,
        systemIdentifier: utils_1.Binary.toCString(buffer.slice(26, 58)),
        generatingSoftware: utils_1.Binary.toCString(buffer.slice(58, 90)),
        fileCreationDayOfYear: dv.getUint16(90, true),
        fileCreationYear: dv.getUint16(92, true),
        headerLength: dv.getUint16(94, true),
        pointDataOffset: dv.getUint32(96, true),
        vlrCount: dv.getUint32(100, true),
        pointDataRecordFormat: dv.getUint8(104) & 0b1111,
        pointDataRecordLength: dv.getUint16(105, true),
        pointCount: dv.getUint32(107, true),
        pointCountByReturn: parseLegacyNumberOfPointsByReturn(buffer.slice(111, 131)),
        scale: (0, utils_2.parsePoint)(buffer.slice(131, 155)),
        offset: (0, utils_2.parsePoint)(buffer.slice(155, 179)),
        min: [
            dv.getFloat64(187, true),
            dv.getFloat64(203, true),
            dv.getFloat64(219, true),
        ],
        max: [
            dv.getFloat64(179, true),
            dv.getFloat64(195, true),
            dv.getFloat64(211, true),
        ],
        waveformDataOffset: 0,
        evlrOffset: 0,
        evlrCount: 0,
    };
    if (minorVersion == 2)
        return header;
    return {
        ...header,
        pointCount: (0, utils_1.parseBigInt)((0, utils_1.getBigUint64)(dv, 247, true)),
        pointCountByReturn: parseNumberOfPointsByReturn(buffer.slice(255, 375)),
        waveformDataOffset: (0, utils_1.parseBigInt)((0, utils_1.getBigUint64)(dv, 227, true)),
        evlrOffset: (0, utils_1.parseBigInt)((0, utils_1.getBigUint64)(dv, 235, true)),
        evlrCount: dv.getUint32(243, true),
    };
}
function parseNumberOfPointsByReturn(buffer) {
    const dv = utils_1.Binary.toDataView(buffer);
    const bigs = [];
    for (let offset = 0; offset < 15 * 8; offset += 8) {
        bigs.push((0, utils_1.getBigUint64)(dv, offset, true));
    }
    return bigs.map((v) => (0, utils_1.parseBigInt)(v));
}
function parseLegacyNumberOfPointsByReturn(buffer) {
    const dv = utils_1.Binary.toDataView(buffer);
    const v = [];
    for (let offset = 0; offset < 5 * 4; offset += 4) {
        v.push(dv.getUint32(offset, true));
    }
    return v;
}
