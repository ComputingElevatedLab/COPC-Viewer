"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bounds = void 0;
exports.Bounds = {
    min,
    max,
    mid,
    width,
    depth,
    height,
    cube,
    step,
    stepTo,
    intersection,
};
function min(b) {
    return [b[0], b[1], b[2]];
}
function max(b) {
    return [b[3], b[4], b[5]];
}
function mid([minx, miny, minz, maxx, maxy, maxz]) {
    return [
        minx + (maxx - minx) / 2,
        miny + (maxy - miny) / 2,
        minz + (maxz - minz) / 2,
    ];
}
function width(bounds) {
    return bounds[3] - bounds[0];
}
function depth(bounds) {
    return bounds[4] - bounds[1];
}
function height(bounds) {
    return bounds[5] - bounds[2];
}
function cube(bounds) {
    const point = mid(bounds);
    const radius = Math.max(width(bounds), depth(bounds), height(bounds)) / 2;
    return [
        point[0] - radius,
        point[1] - radius,
        point[2] - radius,
        point[0] + radius,
        point[1] + radius,
        point[2] + radius,
    ];
}
function step(bounds, [a, b, c]) {
    const [minx, miny, minz, maxx, maxy, maxz] = bounds;
    const [midx, midy, midz] = mid(bounds);
    return [
        a ? midx : minx,
        b ? midy : miny,
        c ? midz : minz,
        a ? maxx : midx,
        b ? maxy : midy,
        c ? maxz : midz,
    ];
}
function stepTo(bounds, [d, x, y, z]) {
    for (let i = d - 1; i >= 0; --i) {
        bounds = step(bounds, [(x >> i) & 1, (y >> i) & 1, (z >> i) & 1]);
    }
    return bounds;
}
function intersection(a, b) {
    return [
        Math.max(a[0], b[0]),
        Math.max(a[1], b[1]),
        Math.max(a[2], b[2]),
        Math.min(a[3], b[3]),
        Math.min(a[4], b[4]),
        Math.min(a[5], b[5]),
    ];
}
