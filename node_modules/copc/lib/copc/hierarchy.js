"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hierarchy = void 0;
const utils_1 = require("../utils");
const constants_1 = require("./constants");
exports.Hierarchy = { parse, load };
function parse(buffer) {
    const dv = utils_1.Binary.toDataView(buffer);
    if (dv.byteLength % constants_1.hierarchyItemLength !== 0) {
        throw new Error(`Invalid hierarchy page length: ${dv.byteLength}`);
    }
    const nodes = {};
    const pages = {};
    for (let i = 0; i < dv.byteLength; i += constants_1.hierarchyItemLength) {
        const d = dv.getInt32(i + 0, true);
        const x = dv.getInt32(i + 4, true);
        const y = dv.getInt32(i + 8, true);
        const z = dv.getInt32(i + 12, true);
        const offset = (0, utils_1.parseBigInt)((0, utils_1.getBigUint64)(dv, i + 16, true));
        const length = dv.getInt32(i + 24, true);
        const pointCount = dv.getInt32(i + 28, true);
        const key = utils_1.Key.toString([d, x, y, z]);
        if (pointCount < -1) {
            throw new Error(`Invalid hierarchy point count at key: ${key}`);
        }
        else if (pointCount === -1) {
            pages[key] = {
                pageOffset: offset,
                pageLength: length,
            };
        }
        else {
            nodes[key] = {
                pointCount,
                pointDataOffset: offset,
                pointDataLength: length,
            };
        }
    }
    return { nodes, pages };
}
async function load(filename, page) {
    const get = utils_1.Getter.create(filename);
    return parse(await get(page.pageOffset, page.pageOffset + page.pageLength));
}
